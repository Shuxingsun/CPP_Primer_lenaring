# 动态内存

- 对象的生命周期：
  - 全局对象在程序启动时分配，结束时销毁。
  - 局部对象在进入程序块时创建，离开块时销毁。
  - 局部`static`对象在第一次使用前分配，在程序结束时销毁。
  - 动态分配对象：只能显式地被释放。
- 对象的内存位置：
  - **静态内存**用来保存局部`static`对象、类`static`对象、定义在任何函数之外的变量。
  - **栈内存**用来保存定义在函数内的非`static`对象。
  - **(heap)堆内存**，又称自由空间，用来存储**动态分配**的对象。

## 动态内存与智能指针

- 动态内存管理：
  - `new`：在动态内存中为对象分配空间并返回一个指向该对象的指针。
  - `delete`：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
- 智能指针：
  - 管理动态对象。
    - 定义在`memory`头文件中
  - 行为类似常规指针。
  - 负责自动释放所指向的对象。
  - 智能指针也是模板。
  - 两种：`shared_ptr`允许多个指针指向同一个对象；`unique_ptr`独占指向的对象
  - `weak_ptr`弱引用，指向`shared_ptr`的对象

### `shared_ptr`类



`shared_ptr`和`unique_ptr`都支持的操作：

| **操作**                                  | **解释**                                                     |
| ----------------------------------------- | ------------------------------------------------------------ |
| **`shared_ptr<T> sp` `unique_ptr<T> up`** | **空智能指针，可以指向类型是`T`的对象**                      |
| **`p`**                                   | **将`p`用作一个条件判断，若`p`指向一个对象，则为`true`**     |
| **`*p`**                                  | **解引用`p`，获得它指向的对象。**                            |
| **`p->mem`**                              | **等价于`(*p).mem`**                                         |
| `p.get()`                                 | 返回`p`中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。 |
| `swap(p, q)` `p.swap(q)`                  | 交换`p`和`q`中的指针                                         |

**shared_ptr独有的操作：**

| **操作**                   | **解释**                                                     |
| -------------------------- | ------------------------------------------------------------ |
| **`make_shared<T>(args)`** | **返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象。** |
| **`shared_ptr<T>p(q)`**    | **`p`是`shared_ptr q`的拷贝；此操作会递增`q`中的计数器。`q`中的指针必须能转换为`T*`** |
| **`p = q`**                | **`p`和`q`都是`shared_ptr`，所保存的指针必须能互相转换。此操作会递减`p`的引用计数，递增`q`的引用计数；若`p`的引用计数变为0，则将其管理的原内存释放。** |
| **`p.unique()`**           | **若`p.use_count()`是1，返回`true`；否则返回`false`**        |
| **`p.use_count()`**        | **返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试。** |

- `make_shared`

  - 最安全的分配和使用动态内存的方法

  - 必须指定创建对象类型

    ```cpp
    shared_ptr<int> p2 = make_shared<int>(42)
    ```

  - 通常使用`auto`来保存`make_shared`的对象

- `shared_ptr`的拷贝和赋值

  - 每个`shared_ptr`都有一个计数器，称为**引用计数**
  - 拷贝`shared_ptr`，计数器递增。**或者将它作为一个参数传递给一个函数**或者**作为函数返回值**
  - **给`shared_ptr`赋予新值时或者`shared_ptr`被销毁**，计数器递减，计数器为0，自动释放内存空间

- **`shared_ptr`自动销毁所管理的对象**

- **使用动态内存的三种原因**：

  - **程序不知道自己需要使用多少对象（比如容器类）。**
  - **程序不知道所需要对象的准确类型。**
  - **程序需要在多个对象间共享数据。**
# 泛型算法

## 概述

- 因为它们实现共同的操作，所以称之为“**算法**”；而“**泛型**”、指的是它们可以操作在多种容器类型上。
- **泛型算法**能够做其他操作，比如查找特定元素，替换、或删除一个特定值，重排元素顺序
- **泛型算法本身不执行容器操作**，只是单独依赖迭代器和迭代器操作实现。
- 头文件： `#include <algorithm>`或者 `#include <numeric>`(算数相关)
- 大多数算法是通过遍历两个迭代器标记的一段元素来实现其功能。
- 必要的编程假定：算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但不能直接添加或者删除元素。

### find

- `vector<int>::const_iterator result = find(vec.begin(), vec.end(), search_value);`
- 输入：两个标记范围的迭代器和目标查找值。返回：如果找到，返回对应的迭代器，否则返回第二个参数，即标记结尾的迭代器。

## 初识泛型算法

- 标准库提供了超过100个算法，但这些算法有一致的结构。
- 理解算法的最基本的方法是了解它们是否读取元素、改变元素、重排元素顺序。

### 只读算法

- <u>只读取范围中的元素，不改变元素</u>。

- 如 `find`和 `accumulate`（在`numeric`中定义，求和）。

- `find_first_of`，输入：两对迭代器标记两段范围，在第一段中找第二段中任意元素，返回第一个匹配的元素，找不到返回第一段的`end`迭代器。

- 算法与元素类型匹配

  ```cpp
  string sum = accumulate(v.cbegin(),v.cend(),"")
  // 传递字符串字面值，const char*没有+远算符
  //可以替换成string("")
  ```

- 通常最好使用`cbegin`和`cend`。

- `equal`：确定两个序列是否保存相同的值。**前提**：第二个序列至少与第一个序列一样长

### 写容器元素的算法

算法要求的只是能够**比较两个序列中的元素**，**不必在乎两个序列的元素来自不同的容器**。

- 迭代器参数

  - 三个迭代器：前两个表示第一个序列的元素范围，第三个表示第二个序列的首元素
  - 四个迭代器：前两个表示第一个序列的元素范围，后两个表示第二个序列的元素范围

- 算法不检查写操作

- back_inserter()指向容器引用，返回绑定的插入迭代器，通过给它赋值，调用push_back将给定值添加到容器中

  ```cpp
  vector<int> vec;
  fill_n(vec.begin(),10,0)  //vec是空元素，语句是未定义的
   
  fill_n(back_inserter(vec),10,0) /
  ```

### 重排容器元素的算法

- 这些算法会重排容器中元素的顺序。

- 排序算法sort：

  - 接受两个迭代器，表示要排序的元素范围。

- 消除重复`unique` ：

  - 之前要先调用`sort`
  - 返回的迭代器指向最后一个不重复元素之后的位置。
  - 顺序会变，重复的元素被“删除”。
  - 并没有真正删除，真正删除必须使用容器操作。

## 定制操作

### 向算法传递函数：

- 谓词（`predicate`）：

  - 是一个**可调用的表达式**，返回结果是一个能用作条件的值
  - 一元谓词：接受一个参数
  - 二元谓词：接受两个参数

- 例子：

  - ` stable_sort：`
    - 保留相等元素的原始相对位置。
    - `stable_sort(words.begin(), words.end(), isShorter);`

### lambda表达式

- 有时可能希望操作可以接受更多的参数。
- `lambda`表达式表示一个可调用的代码单元，可以理解成是一个未命名的内联函数。
- 形式：`[capture list](parameter list) -> return type {function body}`。
  - 其中`capture list`捕获列表是一个`lambda`所在函数定义的局部变量的列表（通常为空）。不可忽略。
  - `return type`是返回类型。可忽略。
  - `parameter`是参数列表。可忽略。
  - `function body`是函数体。不可忽略。
  - `auto f = [] {return 42;}`

- 例子：

  - `find_if`:
    - 接受一对表示范围的迭代器和一个谓词，用来查找第一个满足特定要求的元素。返回第一个使谓词返回非0值的元素。
    - `auto wc = find_if(words.begin(), words.end(), [sz](const string &a){return a.size() >= sz;});`

  - `for_each`：
    - 接受一个可调用对象，并对序列中每个元素调用此对象。
    - `for_each(wc, words.end(), [](const string &s){cout << s << " ";})`
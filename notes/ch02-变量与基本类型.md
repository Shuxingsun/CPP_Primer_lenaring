# 变量与基本类型

##  基本内置类型

### 算术类型：

| 类型          | 含义           | 最小尺寸                       |
| ------------- | -------------- | ------------------------------ |
| `bool`        | 布尔类型       | 8bits                          |
| `char`        | 字符           | 8bits                          |
| `wchar_t`     | 宽字符         | 16bits                         |
| `char16_t`    | Unicode字符    | 16bits                         |
| `char32_t`    | Unicode字符    | 32bits                         |
| `short`       | 短整型         | 16bits                         |
| `int`         | 整型           | 16bits (在32位机器中是32bits)  |
| `long`        | 长整型         | 32bits                         |
| `long long`   | 长整型         | 64bits （是在C++11中新定义的） |
| `float`       | 单精度浮点数   | 6位有效数字                    |
| `double`      | 双精度浮点数   | 10位有效数字                   |
| `long double` | 扩展精度浮点数 | 10位有效数字                   |

#### 符号类型和无符号类型

除去布尔型和扩展的字符型之外，其它**整型**划分为`signed`和`usigned`

无符号类型：在`int`,`short`,`long`...前面加`unsigned`。

**字符型**分为三种，`char` 、`signed char` 、`unsigned char`。三种

字符的表现形式只有：带符号的和不带符号的。

**如何选择类型**

- 1.当明确知晓数值不可能是负数时，选用无符号类型；
- 2.使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。除非超过了`int`的范围，选择`long long`。
- 3.算术表达式中不要使用`char`或`bool`。
- 4.浮点运算选用`double`。

### 类型转换

- 非布尔型赋给布尔型，初始值为0则结果为false，否则为true。
- 布尔型赋给非布尔型，初始值为false结果为0，初始值为true结果为1。
- 浮点数赋给整数类型，仅保留整数部分
- 整数值赋给浮点，小数部记为0
- 给无符号类型赋值一个超出表示范围的值，结果为取模后的值
- 给符号类型赋值超出表示范围的值，结果是未定义的，程序可能继续工作，可能崩溃

**提示：**切勿混用带符号类型和无符号类型

### 字面值常量

一个形如`42`的值被称作**字面值常量**（literal）。

* 整型和浮点型字面值 

整型：写作十进制数、八进制数。。

浮点型：小数或科学计数表示的指数

* 字符和字符串字面值
  * char型字面值 ——单引号：'a'
  * 字符串型字面值——双引号："hello"

* 转义序列。`\n`、`\t`等。
* 布尔字面值。`true`，`false`。
* 指针字面值。`nullptr`



## 变量

**变量**提供一个**具名**的、可供程序操作的存储空间。 `C++`中**变量**和**对象**一般可以互换使用

### 变量定义

* **定义形式：**类型说明符（type specifier） + 一个或多个变量名组成的列表。如`int sum = 0, value, units_sold = 0;`。
* **初始化：**对象在创建时，获得一个特定的值
  * **初始化不是赋值**
  * 初始化 = 创建变量 + 赋予初始值
  * 赋值 = 擦除对象的当前值 + 用新值代替
* **列表初始化：**使用花括号`{}`。例如`int c{12}`
* **默认初始化：**定义时没有指定初始值会被默认初始化。**在函数体内部的内置类型变量将不会被初始化**。
* 建议初始化每一个内置类型的变量。

### 变量声明（declaration）和定义(definition)关系

* **声明**使得名字为程序所知。**定义**负责创建与名字关联的实体.
* **extern**：只是说明变量定义在其他地方。
* 声明一个变量，在类型名添加`extern`.而且不能显示初始化变量

```cpp
extern int i;  //声明i而非定义i
int j;		   //声明并定义j
extern double pi = 3.1415 // 定义
```

* 变量只能被定义一次，但是可以多次声明。定义只出现在一个文件中，其他文件使用该变量时需要对其声明。

### 标识符

#### 变量命名规范

* 需体现实际意义

* 变量名用小写字母

* 自定义类名用大写字母开头：Sales_item

* 标识符由多个单词组成，中间须有明确区分：`student_loan`或`studentLoan`，不要用`studentloan`。

### 名字作用域

全局作用域(global scope)、块作用域（block scope）

## 复合类型

### 引用（reference）

> 引用一般指左值引用

```cpp
int val = 2;
int &refval = val; //refval 是val的另一个名字
```

* 引用必须初始化
* 引用和它的初始值是**绑定bind**在一起的，而**不是拷贝**。一旦定义就不能更改绑定为其他的对象
* 引用即别名，引用并非对象
* 引用必须绑定在**对象上**，不能与字面值或某个表达式计算结果绑定。

### 指针(pointer)

> 1. 指针本身是一个对象，允许对指针复制和拷贝，而且在指针生命周期内可以先后指向不同的对象
> 2. 指针无须在定义时赋值

定义指针：`int *d`

* 获取对象的地址

  * 指针存放某个对象的**地址**。

  * `&`是**取地址符**

  * ```cpp
    // 
    int i=42; int *p = &i; //初始值时int 对象的地址
    int *d = i;				//初始值时指向int 对象的指针
    ```

* 指针的类型与所指向的对象类型必须一致（均为同一类型int、double等）

* 指针值

  * 1.指向一个对象；

  * 2.指向紧邻对象的下一个位置；

  * 3.空指针；

  * 4.无效指针。

  * > **对无效指针的操作均会引发错误，第二种和第三种虽为有效的，但理论上是不被允许的**

* 指针访问对象

  * 使用**解引用操作符**（`*`）来访问对象
  * `cout << *p;`输出p指针所指对象的数据

* 空指针不指向任何对象。使用`int *p=nullptr;`来使用空指针

* > 指针和引用的区别：引用本身并非一个对象，引用定义后就不能绑定到其他的对象了；指针并没有此限制，相当于变量一样使用。

- `void*`指针可以存放**任意**对象的地址。因无类型，仅操作内存空间，对所存对象无法访问。

- 建议：初始化所有指针。
- `int* p1, p2;//*是对p1的修饰，所以p2还是int型`

## const限定符

* 动机：希望定义一些不能被改变值的变量

#### 初始化和const

- const对象**必须初始化**，且**不能被改变**。
- const变量默认不能被其他文件访问，非要访问，必须在指定const定义之前加extern。要想在多个文件中使用const变量共享，定义和声明都加const关键字即可。
- 利用一个对象去初始化另一个对象，他们是不是const都无关紧要。

```cpp
int i = 21;
const int ci = i;
int j = ci;
```

### const引用

- **reference to const**（对常量的引用）：指向const对象的引用，如 `const int ival=1; const int &refVal = ival;`，可以读取但不能修改`refVal`。
- **临时量**（temporary）对象：当编译器需要一个空间来暂存表达式的求值结果时，临时创建的一个未命名的对象。
- 对临时量的引用是非法行为。

### 指针和const

- **pointer to const**（指向常量的指针）：不能用于改变其所指对象的值, 如 `const double pi = 3.14; const double *cptr = π`。
- **const pointer**（常量指针）：指针本身是常量，也就是说指针固定指向该对象，（存放在指针中的地址不变，地址所对应的那个对象值可以修改）如 `int i = 0; int *const ptr = &i;`

### 顶层const

- `顶层const`：指针本身是个常量。
- `底层const`：指针指向的对象是个常量。拷贝时严格要求相同的底层const资格。

```cpp
int i = 0;
int *const pi = &i;  //顶层，不能改变p1的值
const int ci = 42;		//顶层，不能改变c1的值
const int *p2 = &ci;	//允许改变p2的值，底层。指向常量的指针
const int &r = ci; 		//用于声明引用的const都是底层const
```

## 处理类型

### 类型别名

两种方法命名：

- 传统别名：使用**typedef**来定义类型的同义词。 `typedef double wages;`
- 新标准别名：别名声明（alias declaration）： `using SI = Sales_item;`（C++11）

### auto类型说明符 c++11

- **auto**类型说明符：让编译器**自动推断类型**。
- 一条声明语句只能有一个数据类型，所以一个auto声明多个变量时只能相同的变量类型(包括复杂类型&和*)。`auto sz = 0, pi =3.14//错误`
- `int i = 0, &r = i; auto a = r;` 推断`a`的类型是`int`。
- 会忽略`顶层const`。

### decltype类型指示符

- 从表达式的类型推断出要定义的变量的类型。

- **decltype**：选择并返回操作数的**数据类型**。

- `decltype(f()) sum = x;` 推断`sum`的类型是函数`f`的返回类型。

- 不会忽略`顶层const`。

- 如果对变量加括号，编译器会将其认为是一个表达式，如int i-->(i),则decltype((i))得到结果为int&引用。

- 赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。也就是说，如果 i 是 int，则表达式 i=x 的类型是 int&。

  

## 自定义数据结构

预处理器概述：

- **预处理器**（preprocessor）：确保头文件多次包含仍能安全工作。

- 当预处理器看到`#include`标记时，会用指定的头文件内容代替`#include`

- 头文件保护符

  （header guard）：头文件保护符依赖于预处理变量的状态：已定义和未定义。

  - `#indef`已定义时为真
  - `#inndef`未定义时为真
  - 头文件保护符的名称需要唯一，且保持全部大写。养成良好习惯，不论是否该头文件被包含，要加保护符。

```cpp
#ifndef SALES_DATA_H  //SALES_DATA_H未定义时为真
#define SALES_DATA_H
strct Sale_data{
    ...
}
#endif
```